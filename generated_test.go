// Code generated by avo.go. DO NOT EDIT.

package vectorcmp

import "testing"

import "bytes"

func TestVectorEquals8(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint8]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorEquals8(want, 'b', buf)
	goVectorEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorEquals8(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorEquals8(dst, 'b', buf)
	}
}
func BenchmarkGoVectorEquals8(b *testing.B) {
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorEquals(dst, 'b', buf)
	}
}
func TestVectorNotEquals8(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint8]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorNotEquals8(want, 'b', buf)
	goVectorNotEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorNotEquals8(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorNotEquals8(dst, 'b', buf)
	}
}
func BenchmarkGoVectorNotEquals8(b *testing.B) {
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorNotEquals(dst, 'b', buf)
	}
}
func TestVectorGreaterThan8(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint8]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterThan8(want, 'b', buf)
	goVectorGreaterThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterThan8(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterThan8(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterThan8(b *testing.B) {
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterThan(dst, 'b', buf)
	}
}
func TestVectorLessThan8(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint8]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLessThan8(want, 'b', buf)
	goVectorLessThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLessThan8(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLessThan8(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLessThan8(b *testing.B) {
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLessThan(dst, 'b', buf)
	}
}
func TestVectorGreaterEquals8(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint8]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterEquals8(want, 'b', buf)
	goVectorGreaterEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterEquals8(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterEquals8(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterEquals8(b *testing.B) {
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterEquals(dst, 'b', buf)
	}
}
func TestVectorLesserEquals8(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint8]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLesserEquals8(want, 'b', buf)
	goVectorLesserEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLesserEquals8(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLesserEquals8(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLesserEquals8(b *testing.B) {
	buf := randomBuffer[uint8]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLesserEquals(dst, 'b', buf)
	}
}
func TestVectorEquals16(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint16]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorEquals16(want, 'b', buf)
	goVectorEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorEquals16(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorEquals16(dst, 'b', buf)
	}
}
func BenchmarkGoVectorEquals16(b *testing.B) {
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorEquals(dst, 'b', buf)
	}
}
func TestVectorNotEquals16(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint16]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorNotEquals16(want, 'b', buf)
	goVectorNotEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorNotEquals16(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorNotEquals16(dst, 'b', buf)
	}
}
func BenchmarkGoVectorNotEquals16(b *testing.B) {
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorNotEquals(dst, 'b', buf)
	}
}
func TestVectorGreaterThan16(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint16]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterThan16(want, 'b', buf)
	goVectorGreaterThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterThan16(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterThan16(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterThan16(b *testing.B) {
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterThan(dst, 'b', buf)
	}
}
func TestVectorLessThan16(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint16]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLessThan16(want, 'b', buf)
	goVectorLessThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLessThan16(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLessThan16(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLessThan16(b *testing.B) {
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLessThan(dst, 'b', buf)
	}
}
func TestVectorGreaterEquals16(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint16]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterEquals16(want, 'b', buf)
	goVectorGreaterEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterEquals16(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterEquals16(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterEquals16(b *testing.B) {
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterEquals(dst, 'b', buf)
	}
}
func TestVectorLesserEquals16(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint16]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLesserEquals16(want, 'b', buf)
	goVectorLesserEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLesserEquals16(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLesserEquals16(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLesserEquals16(b *testing.B) {
	buf := randomBuffer[uint16]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLesserEquals(dst, 'b', buf)
	}
}
func TestVectorEquals32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorEquals32(want, 'b', buf)
	goVectorEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorEquals32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorEquals32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorEquals32(b *testing.B) {
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorEquals(dst, 'b', buf)
	}
}
func TestVectorEqualsFloat32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorEqualsFloat32(want, 'b', buf)
	goVectorEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorEqualsFloat32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorEqualsFloat32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorEqualsFloat32(b *testing.B) {
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorEquals(dst, 'b', buf)
	}
}
func TestVectorNotEquals32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorNotEquals32(want, 'b', buf)
	goVectorNotEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorNotEquals32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorNotEquals32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorNotEquals32(b *testing.B) {
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorNotEquals(dst, 'b', buf)
	}
}
func TestVectorNotEqualsFloat32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorNotEqualsFloat32(want, 'b', buf)
	goVectorNotEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorNotEqualsFloat32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorNotEqualsFloat32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorNotEqualsFloat32(b *testing.B) {
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorNotEquals(dst, 'b', buf)
	}
}
func TestVectorGreaterThan32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterThan32(want, 'b', buf)
	goVectorGreaterThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterThan32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterThan32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterThan32(b *testing.B) {
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterThan(dst, 'b', buf)
	}
}
func TestVectorGreaterThanFloat32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterThanFloat32(want, 'b', buf)
	goVectorGreaterThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterThanFloat32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterThanFloat32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterThanFloat32(b *testing.B) {
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterThan(dst, 'b', buf)
	}
}
func TestVectorLessThan32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLessThan32(want, 'b', buf)
	goVectorLessThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLessThan32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLessThan32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLessThan32(b *testing.B) {
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLessThan(dst, 'b', buf)
	}
}
func TestVectorLessThanFloat32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLessThanFloat32(want, 'b', buf)
	goVectorLessThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLessThanFloat32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLessThanFloat32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLessThanFloat32(b *testing.B) {
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLessThan(dst, 'b', buf)
	}
}
func TestVectorGreaterEquals32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterEquals32(want, 'b', buf)
	goVectorGreaterEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterEquals32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterEquals32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterEquals32(b *testing.B) {
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterEquals(dst, 'b', buf)
	}
}
func TestVectorGreaterEqualsFloat32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterEqualsFloat32(want, 'b', buf)
	goVectorGreaterEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterEqualsFloat32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterEqualsFloat32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterEqualsFloat32(b *testing.B) {
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterEquals(dst, 'b', buf)
	}
}
func TestVectorLesserEquals32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLesserEquals32(want, 'b', buf)
	goVectorLesserEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLesserEquals32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLesserEquals32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLesserEquals32(b *testing.B) {
	buf := randomBuffer[uint32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLesserEquals(dst, 'b', buf)
	}
}
func TestVectorLesserEqualsFloat32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLesserEqualsFloat32(want, 'b', buf)
	goVectorLesserEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLesserEqualsFloat32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLesserEqualsFloat32(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLesserEqualsFloat32(b *testing.B) {
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLesserEquals(dst, 'b', buf)
	}
}
func TestVectorEquals64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorEquals64(want, 'b', buf)
	goVectorEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorEquals64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorEquals64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorEquals64(b *testing.B) {
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorEquals(dst, 'b', buf)
	}
}
func TestVectorEqualsFloat64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorEqualsFloat64(want, 'b', buf)
	goVectorEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorEqualsFloat64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorEqualsFloat64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorEqualsFloat64(b *testing.B) {
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorEquals(dst, 'b', buf)
	}
}
func TestVectorNotEquals64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorNotEquals64(want, 'b', buf)
	goVectorNotEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorNotEquals64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorNotEquals64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorNotEquals64(b *testing.B) {
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorNotEquals(dst, 'b', buf)
	}
}
func TestVectorNotEqualsFloat64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorNotEqualsFloat64(want, 'b', buf)
	goVectorNotEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorNotEqualsFloat64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorNotEqualsFloat64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorNotEqualsFloat64(b *testing.B) {
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorNotEquals(dst, 'b', buf)
	}
}
func TestVectorGreaterThan64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterThan64(want, 'b', buf)
	goVectorGreaterThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterThan64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterThan64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterThan64(b *testing.B) {
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterThan(dst, 'b', buf)
	}
}
func TestVectorGreaterThanFloat64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterThanFloat64(want, 'b', buf)
	goVectorGreaterThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterThanFloat64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterThanFloat64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterThanFloat64(b *testing.B) {
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterThan(dst, 'b', buf)
	}
}
func TestVectorLessThan64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLessThan64(want, 'b', buf)
	goVectorLessThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLessThan64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLessThan64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLessThan64(b *testing.B) {
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLessThan(dst, 'b', buf)
	}
}
func TestVectorLessThanFloat64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLessThanFloat64(want, 'b', buf)
	goVectorLessThan(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLessThanFloat64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLessThanFloat64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLessThanFloat64(b *testing.B) {
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLessThan(dst, 'b', buf)
	}
}
func TestVectorGreaterEquals64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterEquals64(want, 'b', buf)
	goVectorGreaterEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterEquals64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterEquals64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterEquals64(b *testing.B) {
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterEquals(dst, 'b', buf)
	}
}
func TestVectorGreaterEqualsFloat64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorGreaterEqualsFloat64(want, 'b', buf)
	goVectorGreaterEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorGreaterEqualsFloat64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorGreaterEqualsFloat64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorGreaterEqualsFloat64(b *testing.B) {
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorGreaterEquals(dst, 'b', buf)
	}
}
func TestVectorLesserEquals64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[uint64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLesserEquals64(want, 'b', buf)
	goVectorLesserEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLesserEquals64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLesserEquals64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLesserEquals64(b *testing.B) {
	buf := randomBuffer[uint64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLesserEquals(dst, 'b', buf)
	}
}
func TestVectorLesserEqualsFloat64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorLesserEqualsFloat64(want, 'b', buf)
	goVectorLesserEquals(got, 'b', buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorLesserEqualsFloat64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorLesserEqualsFloat64(dst, 'b', buf)
	}
}
func BenchmarkGoVectorLesserEqualsFloat64(b *testing.B) {
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorLesserEquals(dst, 'b', buf)
	}
}
func TestVectorIsNaNFloat32(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float32]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorIsNaNFloat32(want, buf)
	goVectorIsNaN(got, buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorIsNaNFloat32(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorIsNaNFloat32(dst, buf)
	}
}
func BenchmarkGoVectorIsNaNFloat32(b *testing.B) {
	buf := randomBuffer[float32]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorIsNaN(dst, buf)
	}
}
func TestVectorIsNaNFloat64(t *testing.T) {
	t.Parallel()
	buf := randomBuffer[float64]()
	got := destinationBuffer(buf)
	want := destinationBuffer(buf)
	VectorIsNaNFloat64(want, buf)
	goVectorIsNaN(got, buf)
	if !bytes.Equal(want, got) {
		t.Fatalf("ASM version returned a different result:\n%b\n%b", want, got)
	}
}
func BenchmarkAsmVectorIsNaNFloat64(b *testing.B) {
	if !hasAVX2AndBMI2() && !hasAVX() {
		b.Skip("Both AVX and AVX2 are unavailable")
	}
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		VectorIsNaNFloat64(dst, buf)
	}
}
func BenchmarkGoVectorIsNaNFloat64(b *testing.B) {
	buf := randomBuffer[float64]()
	dst := destinationBuffer(buf)
	b.ResetTimer()
	for i := 0; b.N > i; i++ {
		goVectorIsNaN(dst, buf)
	}
}
