// Code generated by avo.go. DO NOT EDIT.

//go:build amd64 && !purego

package vectorcmp

func VectorEquals8(dstMask []byte, b uint8, rows []uint8) {
	if hasAVX2AndBMI2() && len(rows) >= 64 {
		boundsCheck(dstMask, rows)
		asmAVX2EqualsUint8(dstMask, b, rows[:len(rows) & ^63])
		dstMask = dstMask[(len(rows) & ^63)/8:]
		rows = rows[len(rows) & ^63:]
	} else if hasAVX() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVXEqualsUint8(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	}
	goVectorEquals(dstMask, b, rows)
}
func VectorNotEquals8(dstMask []byte, b uint8, rows []uint8) {
	if hasAVX2AndBMI2() && len(rows) >= 64 {
		boundsCheck(dstMask, rows)
		asmAVX2NotEqualsUint8(dstMask, b, rows[:len(rows) & ^63])
		dstMask = dstMask[(len(rows) & ^63)/8:]
		rows = rows[len(rows) & ^63:]
	} else if hasAVX() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVXNotEqualsUint8(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	}
	goVectorNotEquals(dstMask, b, rows)
}
func VectorGreaterThan8(dstMask []byte, b uint8, rows []uint8) {
	if hasAVX2AndBMI2() && len(rows) >= 64 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterThanUint8(dstMask, b, rows[:len(rows) & ^63])
		dstMask = dstMask[(len(rows) & ^63)/8:]
		rows = rows[len(rows) & ^63:]
	} else if hasAVX() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterThanUint8(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	}
	goVectorGreaterThan(dstMask, b, rows)
}
func VectorLessThan8(dstMask []byte, b uint8, rows []uint8) {
	if hasAVX2AndBMI2() && len(rows) >= 64 {
		boundsCheck(dstMask, rows)
		asmAVX2LessThanUint8(dstMask, b, rows[:len(rows) & ^63])
		dstMask = dstMask[(len(rows) & ^63)/8:]
		rows = rows[len(rows) & ^63:]
	} else if hasAVX() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVXLessThanUint8(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	}
	goVectorLessThan(dstMask, b, rows)
}
func VectorGreaterEquals8(dstMask []byte, b uint8, rows []uint8) {
	if hasAVX2AndBMI2() && len(rows) >= 64 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterEqualsUint8(dstMask, b, rows[:len(rows) & ^63])
		dstMask = dstMask[(len(rows) & ^63)/8:]
		rows = rows[len(rows) & ^63:]
	} else if hasAVX() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterEqualsUint8(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	}
	goVectorGreaterEquals(dstMask, b, rows)
}
func VectorLesserEquals8(dstMask []byte, b uint8, rows []uint8) {
	if hasAVX2AndBMI2() && len(rows) >= 64 {
		boundsCheck(dstMask, rows)
		asmAVX2LesserEqualsUint8(dstMask, b, rows[:len(rows) & ^63])
		dstMask = dstMask[(len(rows) & ^63)/8:]
		rows = rows[len(rows) & ^63:]
	} else if hasAVX() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVXLesserEqualsUint8(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	}
	goVectorLesserEquals(dstMask, b, rows)
}
func VectorEquals16(dstMask []byte, b uint16, rows []uint16) {
	if hasAVX2AndBMI2() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVX2EqualsUint16(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	} else if hasAVX() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVXEqualsUint16(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	}
	goVectorEquals(dstMask, b, rows)
}
func VectorNotEquals16(dstMask []byte, b uint16, rows []uint16) {
	if hasAVX2AndBMI2() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVX2NotEqualsUint16(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	} else if hasAVX() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVXNotEqualsUint16(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	}
	goVectorNotEquals(dstMask, b, rows)
}
func VectorGreaterThan16(dstMask []byte, b uint16, rows []uint16) {
	if hasAVX2AndBMI2() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterThanUint16(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	} else if hasAVX() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterThanUint16(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	}
	goVectorGreaterThan(dstMask, b, rows)
}
func VectorLessThan16(dstMask []byte, b uint16, rows []uint16) {
	if hasAVX2AndBMI2() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVX2LessThanUint16(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	} else if hasAVX() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVXLessThanUint16(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	}
	goVectorLessThan(dstMask, b, rows)
}
func VectorGreaterEquals16(dstMask []byte, b uint16, rows []uint16) {
	if hasAVX2AndBMI2() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterEqualsUint16(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	} else if hasAVX() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterEqualsUint16(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	}
	goVectorGreaterEquals(dstMask, b, rows)
}
func VectorLesserEquals16(dstMask []byte, b uint16, rows []uint16) {
	if hasAVX2AndBMI2() && len(rows) >= 32 {
		boundsCheck(dstMask, rows)
		asmAVX2LesserEqualsUint16(dstMask, b, rows[:len(rows) & ^31])
		dstMask = dstMask[(len(rows) & ^31)/8:]
		rows = rows[len(rows) & ^31:]
	} else if hasAVX() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVXLesserEqualsUint16(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	}
	goVectorLesserEquals(dstMask, b, rows)
}
func VectorEquals32(dstMask []byte, b uint32, rows []uint32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2EqualsUint32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXEqualsUint32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorEquals(dstMask, b, rows)
}
func VectorEqualsFloat32(dstMask []byte, b float32, rows []float32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2EqualsFloat32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXEqualsFloat32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorEquals(dstMask, b, rows)
}
func VectorNotEquals32(dstMask []byte, b uint32, rows []uint32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2NotEqualsUint32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXNotEqualsUint32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorNotEquals(dstMask, b, rows)
}
func VectorNotEqualsFloat32(dstMask []byte, b float32, rows []float32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2NotEqualsFloat32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXNotEqualsFloat32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorNotEquals(dstMask, b, rows)
}
func VectorGreaterThan32(dstMask []byte, b uint32, rows []uint32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterThanUint32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterThanUint32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterThan(dstMask, b, rows)
}
func VectorGreaterThanFloat32(dstMask []byte, b float32, rows []float32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterThanFloat32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterThanFloat32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterThan(dstMask, b, rows)
}
func VectorLessThan32(dstMask []byte, b uint32, rows []uint32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2LessThanUint32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXLessThanUint32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLessThan(dstMask, b, rows)
}
func VectorLessThanFloat32(dstMask []byte, b float32, rows []float32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2LessThanFloat32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXLessThanFloat32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLessThan(dstMask, b, rows)
}
func VectorGreaterEquals32(dstMask []byte, b uint32, rows []uint32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterEqualsUint32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterEqualsUint32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterEquals(dstMask, b, rows)
}
func VectorGreaterEqualsFloat32(dstMask []byte, b float32, rows []float32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterEqualsFloat32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterEqualsFloat32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterEquals(dstMask, b, rows)
}
func VectorLesserEquals32(dstMask []byte, b uint32, rows []uint32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2LesserEqualsUint32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXLesserEqualsUint32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLesserEquals(dstMask, b, rows)
}
func VectorLesserEqualsFloat32(dstMask []byte, b float32, rows []float32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2LesserEqualsFloat32(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXLesserEqualsFloat32(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLesserEquals(dstMask, b, rows)
}
func VectorEquals64(dstMask []byte, b uint64, rows []uint64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2EqualsUint64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXEqualsUint64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorEquals(dstMask, b, rows)
}
func VectorEqualsFloat64(dstMask []byte, b float64, rows []float64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2EqualsFloat64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXEqualsFloat64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorEquals(dstMask, b, rows)
}
func VectorNotEquals64(dstMask []byte, b uint64, rows []uint64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2NotEqualsUint64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXNotEqualsUint64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorNotEquals(dstMask, b, rows)
}
func VectorNotEqualsFloat64(dstMask []byte, b float64, rows []float64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2NotEqualsFloat64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXNotEqualsFloat64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorNotEquals(dstMask, b, rows)
}
func VectorGreaterThan64(dstMask []byte, b uint64, rows []uint64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterThanUint64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterThanUint64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterThan(dstMask, b, rows)
}
func VectorGreaterThanFloat64(dstMask []byte, b float64, rows []float64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterThanFloat64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterThanFloat64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterThan(dstMask, b, rows)
}
func VectorLessThan64(dstMask []byte, b uint64, rows []uint64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2LessThanUint64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXLessThanUint64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLessThan(dstMask, b, rows)
}
func VectorLessThanFloat64(dstMask []byte, b float64, rows []float64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2LessThanFloat64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXLessThanFloat64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLessThan(dstMask, b, rows)
}
func VectorGreaterEquals64(dstMask []byte, b uint64, rows []uint64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterEqualsUint64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterEqualsUint64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterEquals(dstMask, b, rows)
}
func VectorGreaterEqualsFloat64(dstMask []byte, b float64, rows []float64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2GreaterEqualsFloat64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXGreaterEqualsFloat64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorGreaterEquals(dstMask, b, rows)
}
func VectorLesserEquals64(dstMask []byte, b uint64, rows []uint64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2LesserEqualsUint64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXLesserEqualsUint64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLesserEquals(dstMask, b, rows)
}
func VectorLesserEqualsFloat64(dstMask []byte, b float64, rows []float64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2LesserEqualsFloat64(dstMask, b, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXLesserEqualsFloat64(dstMask, b, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorLesserEquals(dstMask, b, rows)
}
func VectorIsNaNFloat32(dstMask []byte, rows []float32) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2IsNaNFloat32(dstMask, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXIsNaNFloat32(dstMask, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorIsNaN(dstMask, rows)
}
func VectorIsNaNFloat64(dstMask []byte, rows []float64) {
	if hasAVX2AndBMI2() && len(rows) >= 16 {
		boundsCheck(dstMask, rows)
		asmAVX2IsNaNFloat64(dstMask, rows[:len(rows) & ^15])
		dstMask = dstMask[(len(rows) & ^15)/8:]
		rows = rows[len(rows) & ^15:]
	} else if hasAVX() && len(rows) >= 8 {
		boundsCheck(dstMask, rows)
		asmAVXIsNaNFloat64(dstMask, rows[:len(rows) & ^7])
		dstMask = dstMask[(len(rows) & ^7)/8:]
		rows = rows[len(rows) & ^7:]
	}
	goVectorIsNaN(dstMask, rows)
}
